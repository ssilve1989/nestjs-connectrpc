import type { DescService } from '@bufbuild/protobuf';
import { Controller } from '@nestjs/common';
import { MessagePattern } from '@nestjs/microservices';
import {
  type ConnectRpcPattern,
  ConnectStreamingType,
} from './connect.interfaces.js';
import { metadataStore } from './store.js';

export interface ConnectMethodOptions {
  /** Override the service name (defaults to class name) */
  service?: string;
  /** Override the method name (defaults to decorated method name in camelCase) */
  method?: string;
}

/**
 * Creates a pattern object for the Connect RPC method.
 * Method names should match the camelCase names defined in the protobuf service descriptor.
 */
const createPattern = (
  target: object,
  propertyKey: string,
  streaming: ConnectStreamingType,
  options?: ConnectMethodOptions,
): ConnectRpcPattern => ({
  service: options?.service ?? target.constructor.name,
  rpc: options?.method ?? propertyKey,
  streaming,
});

/**
 * Creates a method decorator for Connect RPC methods
 */
const createMethodDecorator = (
  streaming: ConnectStreamingType,
  options?: ConnectMethodOptions,
): MethodDecorator => {
  return (
    target: object,
    propertyKey: string | symbol,
    descriptor: PropertyDescriptor,
  ) => {
    const pattern = createPattern(
      target,
      String(propertyKey),
      streaming,
      options,
    );
    return MessagePattern(pattern)(target, propertyKey, descriptor);
  };
};

/**
 * Class decorator that registers a Connect RPC service.
 * This decorator registers the service type in the metadata store and
 * applies the NestJS Controller decorator.
 *
 * @param service - The protobuf service descriptor generated by @bufbuild/protobuf
 *
 * @example
 * ```typescript
 * @ConnectService(ElizaService)
 * export class ElizaController {
 *   @ConnectMethod()
 *   say(request: SayRequest): SayResponse {
 *     return { sentence: `Hello ${request.sentence}` };
 *   }
 * }
 * ```
 */
export const ConnectService = (service: DescService): ClassDecorator => {
  return (target) => {
    // Register service in metadata store for router lookup
    metadataStore.set(target.name, service);

    // Apply NestJS Controller decorator
    Controller()(target);
  };
};

/**
 * Method decorator for unary (no streaming) Connect RPC methods.
 * The method receives a single request and returns a single response.
 *
 * @param options - Optional configuration for service/method name overrides
 *
 * @example
 * ```typescript
 * @ConnectMethod()
 * sayHello(request: SayRequest): SayResponse {
 *   return { sentence: `Hello ${request.sentence}` };
 * }
 * ```
 */
export const ConnectMethod = (
  options?: ConnectMethodOptions,
): MethodDecorator =>
  createMethodDecorator(ConnectStreamingType.NO_STREAMING, options);

/**
 * Method decorator for server streaming Connect RPC methods.
 * The method receives a single request and returns an Observable/AsyncGenerator of responses.
 *
 * @param options - Optional configuration for service/method name overrides
 *
 * @example
 * ```typescript
 * @ConnectServerStreaming()
 * *streamData(request: StreamRequest): AsyncGenerator<StreamResponse> {
 *   for (let i = 0; i < 10; i++) {
 *     yield { data: `chunk ${i}` };
 *   }
 * }
 * ```
 */
export const ConnectServerStreaming = (
  options?: ConnectMethodOptions,
): MethodDecorator =>
  createMethodDecorator(ConnectStreamingType.RX_STREAMING, options);

/**
 * Method decorator for client streaming Connect RPC methods.
 * The method receives an AsyncIterable of requests and returns a single response.
 *
 * @param options - Optional configuration for service/method name overrides
 *
 * @example
 * ```typescript
 * @ConnectClientStreaming()
 * async collectData(requests: AsyncIterable<DataRequest>): Promise<DataResponse> {
 *   let total = 0;
 *   for await (const request of requests) {
 *     total += request.value;
 *   }
 *   return { total };
 * }
 * ```
 */
export const ConnectClientStreaming = (
  options?: ConnectMethodOptions,
): MethodDecorator =>
  createMethodDecorator(ConnectStreamingType.PT_STREAMING, options);

/**
 * Method decorator for bidirectional streaming Connect RPC methods.
 * The method receives an AsyncIterable of requests and returns an Observable/AsyncGenerator of responses.
 *
 * @param options - Optional configuration for service/method name overrides
 *
 * @example
 * ```typescript
 * @ConnectBidiStreaming()
 * async *chat(requests: AsyncIterable<ChatRequest>): AsyncGenerator<ChatResponse> {
 *   for await (const request of requests) {
 *     yield { reply: `Echo: ${request.message}` };
 *   }
 * }
 * ```
 */
export const ConnectBidiStreaming = (
  options?: ConnectMethodOptions,
): MethodDecorator =>
  createMethodDecorator(ConnectStreamingType.DUPLEX_STREAMING, options);
